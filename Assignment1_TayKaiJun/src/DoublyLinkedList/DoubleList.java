package DoublyLinkedList;import java.util.Iterator;import java.util.*;public class DoubleList<T> implements ListADT<T>, Iterable<T>{   /**    * Edits made to source file:    * - Created a new remove() method which takes in an integer instead of an element.    * - Created a new addAfter() method which takes in an integer instead of an element.    */   private DoubleNode<T> front,rear;   private int count;   /**    * Creates an empty list using the default capacity.    */   public DoubleList()   {      rear = null;      front = null;      count = 0;   }   /**    * Adds the specified element to this list at the proper location.    * Throws a ElementNotFoundException if the target is not found.    *    * @param element                         the element to be added to this    *                                        list    * @throws NonComparableElementException  if a non comparable element    *                                        exception occurs    */   public void add (T element)   {      Comparable temp;      if (element instanceof Comparable)         temp = (Comparable)element;      else         throw new NonComparableElementException("double ordered list");      DoubleNode<T> traverse = front;      DoubleNode<T> newNode  = new DoubleNode<T>(element);      boolean found = false;      if (isEmpty())      {         front = newNode;         rear = newNode;      }         else if (temp.compareTo(rear.getElement()) >= 0)         {            rear.setNext(newNode);            newNode.setPrevious(rear);            newNode.setNext(null);            rear = newNode;         }         else if (temp.compareTo(front.getElement()) <= 0)         {            front.setPrevious(newNode);            newNode.setNext(front);            newNode.setPrevious(null);            front = newNode;         }      else      {         while ((temp.compareTo(traverse.getElement()) > 0))            traverse = traverse.getNext();         newNode.setNext(traverse);         newNode.setPrevious(traverse.getPrevious());         traverse.getPrevious().setNext(newNode);         traverse.setPrevious(newNode);      }      count++;   }   public void addToFront (T element){	   	DoubleNode<T> n = new DoubleNode<T>(element);	   	if(isEmpty()){	   		rear=n;	   	}	   	else{	   		n.setNext(front);	   	   	front.setPrevious(n);	   	}   		front=n;   		count++;   	}      public void addToRear (T element){	   DoubleNode<T> n = new DoubleNode<T>(element);	   	if(isEmpty()){	   		front=n;	   	}	   	else{	   		n.setPrevious(rear);	   	   	rear.setNext(n);	   	}  		rear=n;  		count++;   }   public void addAfter (T element, T target){	   DoubleNode<T> nodeptr = find (target);	   if (nodeptr == null)		   throw new ElementNotFoundException ("list");	      	      if (nodeptr == rear){	    	  addToRear(element);	      }	      else{	    	  DoubleNode<T> n = new DoubleNode<T>(element);	    	  n.setPrevious(nodeptr);	    	  n.setNext(nodeptr.getNext());	    	  nodeptr.getNext().setPrevious(n);	    	  nodeptr.setNext(n);	    	  count++;	      }   }   /**    * Removes and returns the specified element.    *    * @param currentTab                 the position of the element where the next element    *                                   will be added next to    * @throws ElementNotFoundException  if an element not found exception occurs    */   public void addAfter (T element, int currentTab){      DoubleNode<T> currentNode = front;      for(int i = 1; i < currentTab; i++){         currentNode = currentNode.getNext();      }      if (currentNode == null)         throw new ElementNotFoundException ("list");      if (currentNode == rear){         addToRear(element);      }      else{         DoubleNode<T> n = new DoubleNode<T>(element);         n.setPrevious(currentNode);         n.setNext(currentNode.getNext());         currentNode.getNext().setPrevious(n);         currentNode.setNext(n);         count++;      }   }   /**    * Removes and returns the last element in this list.    *    * @return                           the last element in the list    * @throws EmptyCollectionException  if an empty collection exception occurs    */   public T removeLast () throws EmptyCollectionException   {      T result;      if (isEmpty())         throw new EmptyCollectionException ("list");      result = rear.getElement();      rear = rear.getPrevious();      if (rear==null)        front = null;      else        rear.setNext(null);      count--;      return result;   }   /**    * Removes and returns the first element in this list.    *    * @return                           the first element in the list    * @throws EmptyCollectionException  if an empty collection exception occurs    */   public T removeFirst() throws EmptyCollectionException   {      if (isEmpty())         throw new EmptyCollectionException ("list");      T result = front.getElement();      front = front.getNext();      if (front==null)         rear = null;      else        front.setPrevious(null);      count--;      return result;   }   /**    * Removes and returns the specified element.    *    * @param element                    the element to be removed and returned    *                                   from the list    * @return                           the element that has been removed from    *                                   the list    * @throws ElementNotFoundException  if an element not found exception occurs    */   public T remove (T element)   {      T result;      DoubleNode<T> nodeptr = find (element);      if (nodeptr == null)         throw new ElementNotFoundException ("list");      result = nodeptr.getElement();      /** check to see if front or rear */      if (nodeptr == front)          result = this.removeFirst();      else if (nodeptr == rear)           result = this.removeLast();           else			{			    nodeptr.getNext().setPrevious(nodeptr.getPrevious());             	nodeptr.getPrevious().setNext(nodeptr.getNext());				count--;			}      return result;   }   /**    * Removes and returns the specified element.    *    * @param currentTab                 the position of the element to be removed and returned    *                                   from the list    * @return                           the element that has been removed from    *                                   the list    * @throws ElementNotFoundException  if an element not found exception occurs    */   public T remove (int currentTab)   {      T result;      DoubleNode<T> currentNode = front;      for(int i = 1; i < currentTab; i++){         currentNode = currentNode.getNext();      }      if (currentNode == null)         throw new ElementNotFoundException ("list");      result = currentNode.getElement();      /** check to see if front or rear */      if (currentNode == front)         result = this.removeFirst();      else if (currentNode == rear)         result = this.removeLast();      else      {         currentNode.getNext().setPrevious(currentNode.getPrevious());         currentNode.getPrevious().setNext(currentNode.getNext());         count--;      }      return result;   }   /**    * Returns a reference to the element at the front of this list.    * The element is not removed from the list.  Throws an    * EmptyCollectionException if the list is empty.    *    * @return a reference to the first element in the list    * @throws EmptyCollectionException  if an empty collection exception occurs    */   public T first() throws EmptyCollectionException   {      if (isEmpty())         throw new EmptyCollectionException ("list");      return front.getElement();   }   /**    * Returns a reference to the element at the rear of this list.    * The element is not removed from the list.  Throws an    * EmptyCollectionException if the list is empty.    *    * @return  a reference to the element at the rear of this list    * @throws EmptyCollectionException  if an empty collection exception occurs    */   public T last() throws EmptyCollectionException   {      if (isEmpty())         throw new EmptyCollectionException ("list");      return rear.getElement();   }   /**    * Returns true if this list contains the specified element.    *    * @param target  the item the list is to be searched for    * @return        true if the target is contained in the list    */   public boolean contains (T target)   {      return (find(target) != null);   }   /**    * Returns a reference to the specified element, or null if it    * is not found.    *    * @param target  the element that is to be searched for    * @return        a reference to the target element or null if not found    */   private DoubleNode<T> find (T target)   {      boolean found = false;      DoubleNode<T> traverse = front;      DoubleNode<T> result = null;      if (! isEmpty())         while (! found && traverse != null)            if (target.equals(traverse.getElement()))               found = true;            else               traverse = traverse.getNext();      if (found)         result = traverse;      return result;   }   /**    * Returns true if this list is empty and false otherwise.    *    * @return  true if the list is empty and false if otherwise    */   public boolean isEmpty()   {      return (count == 0);   }   /**    * Returns the number of elements currently in this list.    *    * @return  the integer representation of the number of elements currently    *          in the list    */   public int size()   {      return count;   }   /**    * Returns an iterator for the elements currently in this list.    *    * @return  an iterator over the elements currently in the list    */   public Iterator<T> iterator()   {      return new DoubleIterator<T> (front, count);   }   /**    * Returns a string representation of this list.    *    * @return  a string representation of this list    */   public String toString()   {      String result = "";      DoubleNode<T> traverse = front;      while (traverse != null)         {         result = result + (traverse.getElement()).toString() + "\n";         traverse = traverse.getNext();         }      return result;   }   }